<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>quagmire API documentation</title>
<meta name="description" content="Copyright 2016-2017 Louis Moresi, Ben Mather, Romain Beucher …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>quagmire</code></h1>
</header>
<section id="section-intro">
<p>Copyright 2016-2017 Louis Moresi, Ben Mather, Romain Beucher</p>
<p>Quagmire is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p>Quagmire is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the
GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License
along with Quagmire.
If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Copyright 2016-2017 Louis Moresi, Ben Mather, Romain Beucher

Quagmire is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or any later version.

Quagmire is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Quagmire.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
&#34;&#34;&#34;

from .mesh import PixMesh as _PixMesh
from .mesh import TriMesh as _TriMesh
from .mesh import sTriMesh as _sTriMesh
from petsc4py import PETSc as _PETSc
from .topomesh import TopoMesh as _TopoMeshClass
from .surfmesh import SurfMesh as _SurfaceProcessMeshClass

from . import documentation
from . import tools
from . import function
from . import scaling
from . import equation_systems

try:
    import lavavu
except:
    pass

_display = None

from mpi4py import MPI as _MPI
mpi_rank = _MPI.COMM_WORLD.rank
mpi_size = _MPI.COMM_WORLD.size


class _xvfb_runner(object):
    &#34;&#34;&#34;
    This class will initialise the X virtual framebuffer (Xvfb).
    Xvfb is useful on headless systems. Note that xvfb will need to be
    installed, as will pyvirtualdisplay.
    This class also manages the lifetime of the virtual display driver. When
    the object is garbage collected, the driver is stopped.
    &#34;&#34;&#34;
    def __init__(self):
        from pyvirtualdisplay import Display
        self._xvfb = Display(visible=0, size=(1600, 1200))
        self._xvfb.start()

    def __del__(self):
        if not self._xvfb is None :
            self._xvfb.stop()

import os as _os

# disable collection of data if requested
if &#34;GLUCIFER_USE_XVFB&#34; in _os.environ:
    from mpi4py import MPI as _MPI
    _comm = _MPI.COMM_WORLD
    if _comm.rank == 0:
        _display = _xvfb_runner()


known_basemesh_classes = {&#34;PixMesh&#34;  : _PixMesh, \
                          &#34;TriMesh&#34;  : _TriMesh, \
                          &#34;sTriMesh&#34; : _sTriMesh}


def _get_label(DM):
    &#34;&#34;&#34;
    Retrieves all points in the DM that is marked with a specific label.
    e.g. &#34;boundary&#34;, &#34;coarse&#34;
    &#34;&#34;&#34;

    n = DM.getNumLabels()
    success = False

    for i in range(n):
        label = DM.getLabelName(i)
        if label in known_basemesh_classes:
            success = True
            break

    if not success:
        raise NameError(&#34;Cannot identify mesh type. DM is not valid.&#34;)

    return label


def FlatMesh(DM, *args, **kwargs):
    &#34;&#34;&#34;
    Instantiates a mesh using TriMesh, sTriMesh or PixMesh objects.

    This object contains methods for the following operations:
     - calculating derivatives
     - interpolation (nearest-neighbour, linear, cubic)
     - local smoothing operations
     - identifying node neighbours

    Parameters
    ----------
     DM : PETSc DM object
        Either a DMDA or DMPlex object created using the meshing
        functions within the tools subdirectory

    Returns
    -------
     FlatMesh : object
    &#34;&#34;&#34;

    # get DM label name
    BaseMeshType = _get_label(DM)

    if BaseMeshType in known_basemesh_classes:

        class FlatMeshClass(known_basemesh_classes[BaseMeshType]):

            __count = 0

            @classmethod
            def _count(cls):
                FlatMeshClass.__count += 1
                return FlatMeshClass.__count

            @property
            def id(self):
                return self.__id

            def __init__(self, dm, *args, **kwargs):

                # I can&#39;t see how to do this automatically
                # but it does seem useful to have the ID reflect the
                # mesh type (perhaps)

                if isinstance(self, _TriMesh):
                    self.__id = &#34;trimesh_{}&#34;.format(self._count())
                elif isinstance(self, _PixMesh):
                    self.__id = &#34;pixmesh_{}&#34;.format(self._count())
                else:
                    self.__id = &#34;flatmesh_{}&#34;.format(self._count())

                known_basemesh_classes[BaseMeshType].__init__(self, dm, *args, **kwargs)

                # super(FlatMeshClass, self).__init__(dm, *args, **kwargs)

        return FlatMeshClass(DM, *args, **kwargs)

    else:
      raise TypeError(&#34;Mesh type {:s} unknown\n\
        Known mesh types: {}&#34;.format(BaseMeshType, list(known_basemesh_classes.keys())))

    return

def TopoMesh(DM, *args, **kwargs):
    &#34;&#34;&#34;
    Instantiates a mesh with a height field.
    TopoMesh inherits from FlatMesh.

    This object contains methods for the following operations:
     - calculating the slope from height field
     - constructing downhill matrices
     - cumulative downstream flow
     - handling flat spots and local minima

    Call update_height to initialise these data structures.

    Parameters
    ----------
     DM : PETSc DM object
        Either a DMDA or DMPlex object created using the meshing
        functions within the tools subdirectory

    Returns
    -------
     TopoMesh : object
    &#34;&#34;&#34;

    BaseMeshType = _get_label(DM)

    if BaseMeshType in known_basemesh_classes:
        class TopoMeshClass(known_basemesh_classes[BaseMeshType], _TopoMeshClass):
            def __init__(self, dm, *args, **kwargs):
                known_basemesh_classes[BaseMeshType].__init__(self, dm, *args, **kwargs)
                _TopoMeshClass.__init__(self, *args, **kwargs)
                # super(TopoMeshClass, self).__init__(dm, *args, **kwargs)

        return TopoMeshClass(DM, *args, **kwargs)

    else:
      raise TypeError(&#34;Mesh type {:s} unknown\n\
        Known mesh types: {}&#34;.format(BaseMeshType, list(known_basemesh_classes.keys())))

    return



def SurfaceProcessMesh(DM, *args, **kwargs):
    &#34;&#34;&#34;
    Instantiates a mesh with a height and rainfall field.
    SurfaceProcessMesh inherits from FlatMesh and TopoMesh.

    This object contains methods for the following operations:
     - long-range flow models
     - calculate erosion and deposition rates
     - landscape equilibrium metrics
     - stream-wise smoothing

    Call update_height and update_surface_processes to initialise
    these data structures.

    Parameters
    ----------
     DM : PETSc DM object
        Either a DMDA or DMPlex object created using the meshing
        functions within the tools subdirectory

    Returns
    -------
     SurfaceProcessMesh : object
    &#34;&#34;&#34;

    BaseMeshType = _get_label(DM)

    if BaseMeshType in known_basemesh_classes:
        class SurfaceProcessMeshClass(known_basemesh_classes[BaseMeshType], _SurfaceProcessMeshClass):
            def __init__(self, dm, *args, **kwargs):
                known_basemesh_classes[BaseMeshType].__init__(self, dm, *args, **kwargs)
                _TopoMeshClass.__init__(self, *args, **kwargs)
                _SurfaceProcessMeshClass.__init__(self, *args, **kwargs)
                # super(SurfaceProcessMeshClass, self).__init__(dm, *args, **kwargs)

        return SurfaceProcessMeshClass(DM, *args, **kwargs)

    else:
      raise TypeError(&#34;Mesh type {:s} unknown\n\
        Known mesh types: {}&#34;.format(BaseMeshType, list(known_basemesh_classes.keys())))

    return</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="quagmire.documentation" href="documentation.html">quagmire.documentation</a></code></dt>
<dd>
<div class="desc"><p>Copyright 2016-2017 Louis Moresi, Ben Mather, Romain Beucher …</p></div>
</dd>
<dt><code class="name"><a title="quagmire.equation_systems" href="equation_systems/index.html">quagmire.equation_systems</a></code></dt>
<dd>
<div class="desc"><p>Copyright 2016-2019 Louis Moresi, Ben Mather, Romain Beucher …</p></div>
</dd>
<dt><code class="name"><a title="quagmire.function" href="function/index.html">quagmire.function</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="quagmire.mesh" href="mesh/index.html">quagmire.mesh</a></code></dt>
<dd>
<div class="desc"><p>Copyright 2016-2017 Louis Moresi, Ben Mather, Romain Beucher …</p></div>
</dd>
<dt><code class="name"><a title="quagmire.scaling" href="scaling/index.html">quagmire.scaling</a></code></dt>
<dd>
<div class="desc"><p>The scaling module provides units and scaling capabilities.</p></div>
</dd>
<dt><code class="name"><a title="quagmire.surfmesh" href="surfmesh/index.html">quagmire.surfmesh</a></code></dt>
<dd>
<div class="desc"><p>Copyright 2016-2017 Louis Moresi, Ben Mather, Romain Beucher …</p></div>
</dd>
<dt><code class="name"><a title="quagmire.tools" href="tools/index.html">quagmire.tools</a></code></dt>
<dd>
<div class="desc"><p>Copyright 2016-2017 Louis Moresi, Ben Mather, Romain Beucher …</p></div>
</dd>
<dt><code class="name"><a title="quagmire.topomesh" href="topomesh/index.html">quagmire.topomesh</a></code></dt>
<dd>
<div class="desc"><p>Copyright 2016-2017 Louis Moresi, Ben Mather, Romain Beucher …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="quagmire.FlatMesh"><code class="name flex">
<span>def <span class="ident">FlatMesh</span></span>(<span>DM, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Instantiates a mesh using TriMesh, sTriMesh or PixMesh objects.</p>
<p>This object contains methods for the following operations:
- calculating derivatives
- interpolation (nearest-neighbour, linear, cubic)
- local smoothing operations
- identifying node neighbours</p>
<h2 id="parameters">Parameters</h2>
<p>DM : PETSc DM object
Either a DMDA or DMPlex object created using the meshing
functions within the tools subdirectory</p>
<h2 id="returns">Returns</h2>
<p>FlatMesh : object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FlatMesh(DM, *args, **kwargs):
    &#34;&#34;&#34;
    Instantiates a mesh using TriMesh, sTriMesh or PixMesh objects.

    This object contains methods for the following operations:
     - calculating derivatives
     - interpolation (nearest-neighbour, linear, cubic)
     - local smoothing operations
     - identifying node neighbours

    Parameters
    ----------
     DM : PETSc DM object
        Either a DMDA or DMPlex object created using the meshing
        functions within the tools subdirectory

    Returns
    -------
     FlatMesh : object
    &#34;&#34;&#34;

    # get DM label name
    BaseMeshType = _get_label(DM)

    if BaseMeshType in known_basemesh_classes:

        class FlatMeshClass(known_basemesh_classes[BaseMeshType]):

            __count = 0

            @classmethod
            def _count(cls):
                FlatMeshClass.__count += 1
                return FlatMeshClass.__count

            @property
            def id(self):
                return self.__id

            def __init__(self, dm, *args, **kwargs):

                # I can&#39;t see how to do this automatically
                # but it does seem useful to have the ID reflect the
                # mesh type (perhaps)

                if isinstance(self, _TriMesh):
                    self.__id = &#34;trimesh_{}&#34;.format(self._count())
                elif isinstance(self, _PixMesh):
                    self.__id = &#34;pixmesh_{}&#34;.format(self._count())
                else:
                    self.__id = &#34;flatmesh_{}&#34;.format(self._count())

                known_basemesh_classes[BaseMeshType].__init__(self, dm, *args, **kwargs)

                # super(FlatMeshClass, self).__init__(dm, *args, **kwargs)

        return FlatMeshClass(DM, *args, **kwargs)

    else:
      raise TypeError(&#34;Mesh type {:s} unknown\n\
        Known mesh types: {}&#34;.format(BaseMeshType, list(known_basemesh_classes.keys())))

    return</code></pre>
</details>
</dd>
<dt id="quagmire.SurfaceProcessMesh"><code class="name flex">
<span>def <span class="ident">SurfaceProcessMesh</span></span>(<span>DM, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Instantiates a mesh with a height and rainfall field.
SurfaceProcessMesh inherits from FlatMesh and TopoMesh.</p>
<p>This object contains methods for the following operations:
- long-range flow models
- calculate erosion and deposition rates
- landscape equilibrium metrics
- stream-wise smoothing</p>
<p>Call update_height and update_surface_processes to initialise
these data structures.</p>
<h2 id="parameters">Parameters</h2>
<p>DM : PETSc DM object
Either a DMDA or DMPlex object created using the meshing
functions within the tools subdirectory</p>
<h2 id="returns">Returns</h2>
<p>SurfaceProcessMesh : object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SurfaceProcessMesh(DM, *args, **kwargs):
    &#34;&#34;&#34;
    Instantiates a mesh with a height and rainfall field.
    SurfaceProcessMesh inherits from FlatMesh and TopoMesh.

    This object contains methods for the following operations:
     - long-range flow models
     - calculate erosion and deposition rates
     - landscape equilibrium metrics
     - stream-wise smoothing

    Call update_height and update_surface_processes to initialise
    these data structures.

    Parameters
    ----------
     DM : PETSc DM object
        Either a DMDA or DMPlex object created using the meshing
        functions within the tools subdirectory

    Returns
    -------
     SurfaceProcessMesh : object
    &#34;&#34;&#34;

    BaseMeshType = _get_label(DM)

    if BaseMeshType in known_basemesh_classes:
        class SurfaceProcessMeshClass(known_basemesh_classes[BaseMeshType], _SurfaceProcessMeshClass):
            def __init__(self, dm, *args, **kwargs):
                known_basemesh_classes[BaseMeshType].__init__(self, dm, *args, **kwargs)
                _TopoMeshClass.__init__(self, *args, **kwargs)
                _SurfaceProcessMeshClass.__init__(self, *args, **kwargs)
                # super(SurfaceProcessMeshClass, self).__init__(dm, *args, **kwargs)

        return SurfaceProcessMeshClass(DM, *args, **kwargs)

    else:
      raise TypeError(&#34;Mesh type {:s} unknown\n\
        Known mesh types: {}&#34;.format(BaseMeshType, list(known_basemesh_classes.keys())))

    return</code></pre>
</details>
</dd>
<dt id="quagmire.TopoMesh"><code class="name flex">
<span>def <span class="ident">TopoMesh</span></span>(<span>DM, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Instantiates a mesh with a height field.
TopoMesh inherits from FlatMesh.</p>
<p>This object contains methods for the following operations:
- calculating the slope from height field
- constructing downhill matrices
- cumulative downstream flow
- handling flat spots and local minima</p>
<p>Call update_height to initialise these data structures.</p>
<h2 id="parameters">Parameters</h2>
<p>DM : PETSc DM object
Either a DMDA or DMPlex object created using the meshing
functions within the tools subdirectory</p>
<h2 id="returns">Returns</h2>
<p>TopoMesh : object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TopoMesh(DM, *args, **kwargs):
    &#34;&#34;&#34;
    Instantiates a mesh with a height field.
    TopoMesh inherits from FlatMesh.

    This object contains methods for the following operations:
     - calculating the slope from height field
     - constructing downhill matrices
     - cumulative downstream flow
     - handling flat spots and local minima

    Call update_height to initialise these data structures.

    Parameters
    ----------
     DM : PETSc DM object
        Either a DMDA or DMPlex object created using the meshing
        functions within the tools subdirectory

    Returns
    -------
     TopoMesh : object
    &#34;&#34;&#34;

    BaseMeshType = _get_label(DM)

    if BaseMeshType in known_basemesh_classes:
        class TopoMeshClass(known_basemesh_classes[BaseMeshType], _TopoMeshClass):
            def __init__(self, dm, *args, **kwargs):
                known_basemesh_classes[BaseMeshType].__init__(self, dm, *args, **kwargs)
                _TopoMeshClass.__init__(self, *args, **kwargs)
                # super(TopoMeshClass, self).__init__(dm, *args, **kwargs)

        return TopoMeshClass(DM, *args, **kwargs)

    else:
      raise TypeError(&#34;Mesh type {:s} unknown\n\
        Known mesh types: {}&#34;.format(BaseMeshType, list(known_basemesh_classes.keys())))

    return</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="quagmire.documentation" href="documentation.html">quagmire.documentation</a></code></li>
<li><code><a title="quagmire.equation_systems" href="equation_systems/index.html">quagmire.equation_systems</a></code></li>
<li><code><a title="quagmire.function" href="function/index.html">quagmire.function</a></code></li>
<li><code><a title="quagmire.mesh" href="mesh/index.html">quagmire.mesh</a></code></li>
<li><code><a title="quagmire.scaling" href="scaling/index.html">quagmire.scaling</a></code></li>
<li><code><a title="quagmire.surfmesh" href="surfmesh/index.html">quagmire.surfmesh</a></code></li>
<li><code><a title="quagmire.tools" href="tools/index.html">quagmire.tools</a></code></li>
<li><code><a title="quagmire.topomesh" href="topomesh/index.html">quagmire.topomesh</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="quagmire.FlatMesh" href="#quagmire.FlatMesh">FlatMesh</a></code></li>
<li><code><a title="quagmire.SurfaceProcessMesh" href="#quagmire.SurfaceProcessMesh">SurfaceProcessMesh</a></code></li>
<li><code><a title="quagmire.TopoMesh" href="#quagmire.TopoMesh">TopoMesh</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>